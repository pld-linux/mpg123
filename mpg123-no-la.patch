--- mpg123-1.16.0/src/module.c.orig	2013-10-15 15:34:52.184320390 +0200
+++ mpg123-1.16.0/src/module.c	2013-10-15 16:38:49.842888001 +0200
@@ -167,31 +167,85 @@ mpg123_module_t* open_module_here(const
 }
 
 
-/* Open a module, including directory search. */
+/* Open a module */
 mpg123_module_t* open_module(const char* type, const char* name)
 {
+	lt_dlhandle handle = NULL;
 	mpg123_module_t *module = NULL;
-	char *workdir = NULL;
-	char *moddir  = NULL;
+	char* module_path = NULL;
+	size_t module_path_len = 0;
+	char* module_symbol = NULL;
+	size_t module_symbol_len = 0;
+	char *moddir = get_module_dir();
 
-	workdir = get_the_cwd();
-	moddir  = get_module_dir();
-	if(workdir == NULL || moddir == NULL)
+	if (moddir == NULL)
 	{
-		error("Failure getting workdir or moddir! (Perhaps set MPG123_MODDIR?)");
-		if(workdir == NULL) fprintf(stderr, "Hint: I need to know the current working directory to be able to come back after hunting modules. I will not leave because I do not know where I am.\n");
+		goto ex;
+	}
 
-		if(workdir != NULL) free(workdir);
-		if(moddir  != NULL) free(moddir);
-		return NULL;
+	/* Initialize libltdl */
+	if(lt_dlinit())
+	{
+		error("Failed to initialise libltdl");
+		goto ex;
 	}
 
-	if(chdir(moddir) == 0) module = open_module_here(type, name);
-	else error2("Failed to enter module directory %s: %s", moddir, strerror(errno));
+	/* Work out the path of the module to open */
+	/* Note that we need to open ./file, not just file! */
+	module_path_len = strlen(moddir) + 1 + strlen(type) + 1 + strlen(name) + strlen(MODULE_FILE_SUFFIX) + 1;
+	module_path = malloc( module_path_len );
+	if (module_path == NULL) {
+		error1( "Failed to allocate memory for module name: %s", strerror(errno) );
+		goto ex;
+	}
+	snprintf( module_path, module_path_len, "%s/%s_%s%s", moddir, type, name, MODULE_FILE_SUFFIX );
+	/* Display the path of the module created */
+	if(param.verbose > 1) fprintf(stderr, "Module path: %s\n", module_path );
+
+	/* Open the module */
+	handle = lt_dlopen( module_path );
+	free( module_path );
+	if (handle==NULL) {
+		error2( "Failed to open module %s: %s", name, lt_dlerror() );
+		if(param.verbose > 1)
+		fprintf(stderr, "Note: This could be because of braindead path in the .la file...\n");
+
+		goto ex;
+	}
+	
+	/* Work out the symbol name */
+	module_symbol_len = strlen( MODULE_SYMBOL_PREFIX ) +
+						strlen( type )  +
+						strlen( MODULE_SYMBOL_SUFFIX ) + 1;
+	module_symbol = malloc(module_symbol_len);
+	if (module_symbol == NULL) {
+		error1( "Failed to allocate memory for module symbol: %s", strerror(errno) );
+		goto ex;
+	}
+	snprintf( module_symbol, module_symbol_len, "%s%s%s", MODULE_SYMBOL_PREFIX, type, MODULE_SYMBOL_SUFFIX );
+	debug1( "Module symbol: %s", module_symbol );
+	
+	/* Get the information structure from the module */
+	module = (mpg123_module_t*)lt_dlsym(handle, module_symbol );
+	free( module_symbol );
+	if (module==NULL) {
+		error1( "Failed to get module symbol: %s", lt_dlerror() );
+		goto ex;
+	}
+	
+	/* Check the API version */
+	if (MPG123_MODULE_API_VERSION != module->api_version)
+	{
+		error2( "API version of module does not match (got %i, expected %i).", module->api_version, MPG123_MODULE_API_VERSION);
+		lt_dlclose(handle);
+		module = NULL;
+		goto ex;
+	}
 
-	chdir(workdir);
-	free(moddir);
-	free(workdir);
+	/* Store handle in the data structure */
+	module->handle = handle;
+ex:
+	if (moddir != NULL) free(moddir);
 	return module;
 }
 
